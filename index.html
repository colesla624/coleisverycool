<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Diverse 100-Level Platformer with Cave Flashlight</title>
  <style>
    body { margin:0; background:#111; }
    canvas { display:block; }
    .hud { position:fixed; inset:0; pointer-events:none; }
    .stick-area, .btn { pointer-events:auto; touch-action:none; }
    .stick-area {
      position:fixed; bottom:16px; left:16px; width:120px; height:120px;
      border-radius:50%; background:rgba(255,255,255,0.08);
      border:1px solid rgba(255,255,255,0.12);
    }
    .stick-knob {
      position:absolute; left:50%; top:50%; width:40px; height:40px;
      border-radius:50%; background:#0af; transform:translate(-50%,-50%);
    }
    .btn {
      position:fixed; right:16px; bottom:16px; width:80px; height:80px;
      border-radius:50%; background:#fff; display:flex; align-items:center; justify-content:center;
      font-weight:bold; user-select:none;
    }
    .label {
      position:fixed; top:8px; left:50%; transform:translateX(-50%);
      color:#fff; font-family:sans-serif; font-size:18px; background:rgba(0,0,0,0.4);
      padding:6px 10px; border-radius:8px;
    }
    #skipBtn {
      position:fixed; top:60px; right:20px;
      background:#fff; border:none; padding:8px 12px; border-radius:6px;
      font-weight:bold; display:none; cursor:pointer;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud">
  <div class="label" id="levelLabel">Level 1 | Coins: 0</div>
  <div id="moveStick" class="stick-area"><div id="moveKnob" class="stick-knob"></div></div>
  <div id="jumpBtn" class="btn">Jump</div>
</div>
<button id="skipBtn">Skip Boss</button>

<script>
const canvas = document.getElementById("game"), ctx = canvas.getContext("2d");
function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resize();
window.addEventListener('resize', resize);

// World constants
const TILE=32, GROUND_Y=15*TILE;
let coinTotal=0, hasKey=false;

// Player
const player = {
  x:64, y:GROUND_Y-28, w:24, h:28,
  vx:0, vy:0, onGround:false, jumps:0,
  color:"#ffd166", face:1 // 1 right, -1 left
};

// Input
const keys = {};
window.addEventListener("keydown", e => keys[e.code] = true);
window.addEventListener("keyup", e => keys[e.code] = false);

// Touch joystick
let moveVec={x:0};
(function setupStick(){
  const area=document.getElementById('moveStick'),knob=document.getElementById('moveKnob');
  let active=false,startX=0;
  area.addEventListener('touchstart',e=>{active=true;startX=e.touches[0].clientX;});
  area.addEventListener('touchmove',e=>{
    if(!active)return;
    const dx=e.touches[0].clientX-startX;
    const radius=area.clientWidth/2-20;
    const nx=Math.max(-radius,Math.min(radius,dx));
    knob.style.left=`calc(50% + ${nx}px)`; moveVec.x=nx/radius;
  });
  area.addEventListener('touchend',()=>{active=false;moveVec.x=0;knob.style.left='50%';});
})();

// Double jump
function tryJump(){
  if(player.jumps<2){ player.vy = -520; player.onGround=false; player.jumps++; }
}
document.getElementById('jumpBtn').addEventListener('touchstart', tryJump);

// Utils
function aabb(ax,ay,aw,ah,bx,by,bw,bh){ return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by; }
function onTopOf(ax,ay,aw,ah,bx,by,bw,bh){ return aabb(ax,ay,aw,ah,bx,by,bw,bh) && (ay+ah) <= (by+10) && player.vy>=0; }

// Projectiles
const bullets = [];

// Level data
const levels = [];
let levelIndex = 0;

function setHUD(name){ document.getElementById("levelLabel").textContent = `${name} | Coins: ${coinTotal}`; }

function makeLevelBase(name){
  return {
    name, bg:"#222",
    dark:false, flashlight:true, // caves use darkness with flashlight
    lowGravity:false, friction:1.0,
    conveyorZones:[], // {x,y,w,h,speed}
    platforms:[],     // {x,y,w,h,vx,vy,minX,maxX,minY,maxY}
    hazards:[],       // {x,y,w,h}
    bouncePads:[],    // {x,y,w,h,power}
    breakables:[],    // {x,y,w,h,broken:false}
    door:null,        // {x,y,w,h}
    key:null,         // {x,y,w,h, collected:false}
    coins:[],         // {x,y,r, collected:false}
    enemies:[],       // see types below
    boss:false, bossReward:100,
    goal:{x:canvas.width-120, y:GROUND_Y-32, w:80, h:32}
  };
}

// Theme generators (each world of 10 levels introduces new obstacles and tweaks)
function grasslands(i){
  const L=makeLevelBase(`Level ${i} - Grasslands`);
  L.bg = "#254027";
  for(let k=0;k<4;k++) L.coins.push({x:150+k*100,y:GROUND_Y-90-Math.sin(k)*35,r:10,collected:false});
  L.platforms.push({x:260,y:GROUND_Y-100,w:110,h:12});
  L.platforms.push({x:460,y:GROUND_Y-160,w:120,h:12,vx:40,vy:0,minX:430,maxX:530});
  L.hazards.push({x:620,y:GROUND_Y-16,w:80,h:16});
  L.enemies.push({type:"patrol",x:320,y:GROUND_Y-28,w:24,h:28,dir:1,minX:300,maxX:520,speed:60});
  return L;
}

function caves(i){
  const L=makeLevelBase(`Level ${i} - Caves`);
  L.bg = "#1c1c1c"; L.dark=true; L.flashlight=true;
  L.platforms.push({x:220,y:GROUND_Y-90,w:90,h:12});
  L.platforms.push({x:360,y:GROUND_Y-140,w:80,h:12});
  L.breakables.push({x:360,y:GROUND_Y-152,w:50,h:12,broken:false});
  L.hazards.push({x:170,y:GROUND_Y-16,w:60,h:16});
  L.hazards.push({x:480,y:GROUND_Y-16,w:60,h:16});
  L.coins.push({x:380,y:GROUND_Y-185,r:10, collected:false});
  L.enemies.push({type:"fly",x:420,y:GROUND_Y-120,w:22,h:22,t:0,ampX:40,ampY:25,baseX:420,baseY:GROUND_Y-120,speed:2});
  return L;
}

function sky(i){
  const L=makeLevelBase(`Level ${i} - Sky`);
  L.bg = "#1b2a49";
  L.platforms.push({x:220,y:GROUND_Y-140,w:70,h:12});
  L.platforms.push({x:320,y:GROUND_Y-200,w:70,h:12});
  L.platforms.push({x:420,y:GROUND_Y-260,w:70,h:12});
  L.bouncePads.push({x:180,y:GROUND_Y-16,w:40,h:16,power:920});
  L.coins.push({x:420,y:GROUND_Y-280,r:10, collected:false});
  L.enemies.push({type:"patrol",x:480,y:GROUND_Y-28,w:24,h:28,dir:-1,minX:420,maxX:560,speed:70});
  return L;
}

function lava(i){
  const L=makeLevelBase(`Level ${i} - Lava Fortress`);
  L.bg = "#3b1e1e";
  for(let k=0;k<4;k++) L.hazards.push({x:220+k*110,y:GROUND_Y-16,w:70,h:16});
  L.platforms.push({x:640,y:GROUND_Y-110,w:100,h:12});
  L.enemies.push({type:"chase",x:560,y:GROUND_Y-28,w:24,h:28,speed:95,range:260});
  L.coins.push({x:660,y:GROUND_Y-130,r:10, collected:false});
  return L;
}

function ice(i){
  const L=makeLevelBase(`Level ${i} - Ice Peaks`);
  L.bg = "#173e43"; L.friction = 0.55;
  L.platforms.push({x:300,y:GROUND_Y-100,w:110,h:12});
  L.platforms.push({x:500,y:GROUND_Y-160,w:110,h:12});
  L.hazards.push({x:420,y:GROUND_Y-16,w:60,h:16});
  L.coins.push({x:520,y:GROUND_Y-180,r:10, collected:false});
  L.enemies.push({type:"patrol",x:460,y:GROUND_Y-28,w:24,h:28,dir:1,minX:440,maxX:580,speed:65});
  return L;
}

function factory(i){
  const L=makeLevelBase(`Level ${i} - Factory`);
  L.bg = "#2c2c34";
  L.conveyorZones.push({x:200,y:GROUND_Y-12,w:160,h:12,speed:130});
  L.conveyorZones.push({x:420,y:GROUND_Y-12,w:160,h:12,speed:-140});
  L.platforms.push({x:380,y:GROUND_Y-120,w:110,h:12});
  L.enemies.push({type:"turret",x:540,y:GROUND_Y-48,w:20,h:20,fire:0,rate:1.1});
  L.coins.push({x:400,y:GROUND_Y-140,r:10, collected:false});
  return L;
}

function haunted(i){
  const L=makeLevelBase(`Level ${i} - Haunted Ruins`);
  L.bg = "#252038"; L.dark=true; L.flashlight=true;
  L.platforms.push({x:260,y:GROUND_Y-120,w:110,h:12});
  L.door = {x:500,y:GROUND_Y-72,w:24,h:72};
  L.key = {x:280,y:GROUND_Y-132,w:18,h:18, collected:false};
  L.enemies.push({type:"ghost",x:440,y:GROUND_Y-28,w:24,h:28,t:0,visible:true});
  L.coins.push({x:540,y:GROUND_Y-90,r:10, collected:false});
  return L;
}

function jungle(i){
  const L=makeLevelBase(`Level ${i} - Jungle`);
  L.bg = "#1f3a2d";
  L.platforms.push({x:240,y:GROUND_Y-110,w:90,h:12,vx:70,vy:0,minX:180,maxX:320});
  L.platforms.push({x:440,y:GROUND_Y-190,w:90,h:12,vy:70,minY:GROUND_Y-250,maxY:GROUND_Y-130});
  L.coins.push({x:440,y:GROUND_Y-210,r:10, collected:false});
  L.enemies.push({type:"patrol",x:320,y:GROUND_Y-28,w:24,h:28,dir:1,minX:280,maxX:360,speed:70});
  return L;
}

function space(i){
  const L=makeLevelBase(`Level ${i} - Space`);
  L.bg = "#0a0f1d"; L.lowGravity=true;
  L.platforms.push({x:280,y:GROUND_Y-160,w:90,h:12});
  L.platforms.push({x:420,y:GROUND_Y-230,w:90,h:12});
  L.hazards.push({x:340,y:GROUND_Y-16,w:80,h:16});
  L.enemies.push({type:"fly",x:500,y:GROUND_Y-170,w:22,h:22,t:0,ampX:60,ampY:40,baseX:500,baseY:GROUND_Y-170,speed:1.4});
  L.coins.push({x:420,y:GROUND_Y-250,r:10, collected:false});
  return L;
}

// Boss levels (introduce new obstacle flavor each world boss)
function bossLevel(i){
  const L=makeLevelBase(`Level ${i} - Boss`);
  L.bg="#2a1f1f"; L.boss=true; L.goal=null;
  // World-specific additions
  const world = Math.floor((i-1)/10)+1;
  if(world===1){ L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:80,h:80,hp:6,fire:0,rate:1.0}); }
  else if(world===2){ L.dark=true; L.flashlight=true; L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:80,h:80,hp:7,fire:0,rate:0.95}); }
  else if(world===3){ L.bouncePads.push({x:280,y:GROUND_Y-16,w:50,h:16,power:950}); L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:80,h:80,hp:7,fire:0,rate:0.9}); }
  else if(world===4){ L.hazards.push({x:320,y:GROUND_Y-16,w:90,h:16}); L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:90,h:90,hp:8,fire:0,rate:0.85}); }
  else if(world===5){ L.friction=0.6; L.platforms.push({x:420,y:GROUND_Y-120,w:110,h:12}); L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:90,h:90,hp:8,fire:0,rate:0.8}); }
  else if(world===6){ L.conveyorZones.push({x:260,y:GROUND_Y-12,w:180,h:12,speed:160}); L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:90,h:90,hp:9,fire:0,rate:0.75}); }
  else if(world===7){ L.dark=true; L.flashlight=true; L.door={x:520,y:GROUND_Y-72,w:24,h:72}; L.key={x:300,y:GROUND_Y-132,w:18,h:18, collected:false}; L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:90,h:90,hp:9,fire:0,rate:0.7}); }
  else if(world===8){ L.platforms.push({x:380,y:GROUND_Y-160,w:100,h:12,vy:70,minY:GROUND_Y-220,maxY:GROUND_Y-120}); L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:100,h:100,hp:10,fire:0,rate:0.7}); }
  else if(world===9){ L.lowGravity=true; L.hazards.push({x:360,y:GROUND_Y-16,w:100,h:16}); L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:100,h:100,hp:10,fire:0,rate:0.65}); }
  else { L.lowGravity=true; L.dark=true; L.flashlight=true; L.conveyorZones.push({x:280,y:GROUND_Y-12,w:160,h:12,speed:-170}); L.bouncePads.push({x:460,y:GROUND_Y-16,w:50,h:16,power:980}); L.enemies.push({type:"boss",x:520,y:GROUND_Y-60,w:110,h:110,hp:12,fire:0,rate:0.6}); }
  return L;
}

// Build 100 levels (each world of 10 introduces new obstacles and ends with a boss)
for(let i=1;i<=100;i++){
  let L;
  if(i%10===0) L = bossLevel(i);
  else if(i<=10) L = grasslands(i);
  else if(i<=20) L = caves(i);
  else if(i<=30) L = sky(i);
  else if(i<=40) L = lava(i);
  else if(i<=50) L = ice(i);
  else if(i<=60) L = factory(i);
  else if(i<=70) L = haunted(i);
  else if(i<=80) L = jungle(i);
  else L = space(i); // 81-99
  levels.push(L);
}

// Load/reset
function loadLevel(idx){
  levelIndex = ((idx%levels.length)+levels.length)%levels.length;
  const L = levels[levelIndex];
  hasKey = false;
  player.x = 64; player.y = GROUND_Y-28; player.vx=0; player.vy=0; player.jumps=0; player.onGround=false;
  bullets.length = 0;
  setHUD(L.name);
  document.getElementById("skipBtn").style.display = L.boss ? "block" : "none";
}
loadLevel(0);
document.getElementById("skipBtn").onclick = ()=> loadLevel(levelIndex+1);

// Update
function update(dt){
  const L = levels[levelIndex];
  const gravity = L.lowGravity ? 520 : 1000;
  const baseSpeed = 240;
  const friction = L.friction || 1.0;

  const left = keys["ArrowLeft"] || keys["KeyA"] || moveVec.x < -0.2;
  const right = keys["ArrowRight"] || keys["KeyD"] || moveVec.x > 0.2;
  if(left && !right){ player.vx = -baseSpeed * friction; player.face=-1; }
  else if(right && !left){ player.vx = baseSpeed * friction; player.face=1; }
  else player.vx *= 0.85 * friction;

  if(keys["Space"] || keys["ArrowUp"] || keys["KeyW"]) tryJump();

  // Gravity and movement
  player.vy += gravity * dt;

  // Conveyors
  for(const z of L.conveyorZones){
    if(onTopOf(player.x,player.y,player.w,player.h,z.x,z.y,z.w,z.h)){
      player.x += z.speed * dt;
    }
  }

  player.x += player.vx * dt;
  player.y += player.vy * dt;

  // Ground
  if(player.y + player.h > GROUND_Y){
    player.y = GROUND_Y - player.h;
    player.vy = 0; player.onGround=true; player.jumps=0;
  } else {
    player.onGround=false;
  }

  // Platforms move and land
  for(const p of L.platforms){
    if(p.vx){ p.x += p.vx * dt; if(p.minX!==undefined && (p.x<p.minX || p.x>p.maxX)) p.vx*=-1; }
    if(p.vy){ p.y += p.vy * dt; if(p.minY!==undefined && (p.y<p.minY || p.y>p.maxY)) p.vy*=-1; }
    if(onTopOf(player.x,player.y,player.w,player.h,p.x,p.y,p.w,p.h)){
      player.y = p.y - player.h; player.vy = 0; player.onGround=true; player.jumps=0;
    }
  }

  // Bounce pads
  for(const b of L.bouncePads){
    if(onTopOf(player.x,player.y,player.w,player.h,b.x,b.y,b.w,b.h)){
      player.vy = -b.power; player.onGround=false;
    }
  }

  // Breakables
  for(const br of L.breakables){
    if(!br.broken && onTopOf(player.x,player.y,player.w,player.h,br.x,br.y,br.w,br.h)){
      br.broken = true; player.onGround=false; player.vy = Math.max(player.vy, 50);
    }
  }

  // Door and key
  if(L.key && !L.key.collected && aabb(player.x,player.y,player.w,player.h,L.key.x,L.key.y,L.key.w,L.key.h)){
    L.key.collected = true; hasKey = true;
  }
  if(L.door){
    if(aabb(player.x,player.y,player.w,player.h,L.door.x,L.door.y,L.door.w,L.door.h) && !hasKey){
      if(player.x + player.w/2 < L.door.x + L.door.w/2) player.x = L.door.x - player.w;
      else player.x = L.door.x + L.door.w;
      player.vx = 0;
    }
  }

  // Hazards
  for(const h of L.hazards){
    if(aabb(player.x,player.y,player.w,player.h,h.x,h.y,h.w,h.h)){
      loadLevel(levelIndex); return;
    }
  }

  // Coins
  for(const c of L.coins){
    if(!c.collected && aabb(player.x,player.y,player.w,player.h,c.x-c.r,c.y-c.r,c.r*2,c.r*2)){
      c.collected = true; coinTotal++; setHUD(L.name);
    }
  }

  // Enemies and AI
  for(const e of L.enemies){
    if(e.type==="patrol"){
      e.x += (e.dir*e.speed*dt);
      if(e.x<e.minX){ e.x=e.minX; e.dir*=-1; }
      if(e.x+e.w>e.maxX){ e.x=e.maxX-e.w; e.dir*=-1; }
    } else if(e.type==="fly"){
      e.t += e.speed*dt;
      e.x = e.baseX + Math.sin(e.t)*e.ampX;
      e.y = e.baseY + Math.cos(e.t*0.9)*e.ampY;
    } else if(e.type==="chase"){
      const dx = player.x - e.x;
      if(Math.abs(dx) < e.range) e.x += Math.sign(dx) * e.speed * dt;
    } else if(e.type==="ghost"){
      e.t += dt; e.visible = Math.floor(e.t % 2)===0;
    } else if(e.type==="turret"){
      e.fire = (e.fire||0) + dt;
      if(e.fire >= (e.rate||1)){
        e.fire = 0;
        const bx = e.x + e.w/2, by = e.y + e.h/2;
        const dx = player.x + player.w/2 - bx;
        const dy = player.y + player.h/2 - by;
        const len = Math.max(1, Math.hypot(dx,dy));
        bullets.push({x:bx,y:by,w:6,h:6,vx:(dx/len)*270,vy:(dy/len)*270,ttl:4,color:"#ffcc00"});
      }
    } else if(e.type==="boss"){
      e.fire = (e.fire||0) + dt;
      if(e.fire >= (e.rate||0.9)){
        e.fire = 0;
        const N = 8 + Math.floor(Math.random()*4);
        for(let k=0;k<N;k++){
          const ang = (k/N)*Math.PI*2;
          bullets.push({x:e.x+e.w/2,y:e.y+e.h/2,w:8,h:8,vx:Math.cos(ang)*230,vy:Math.sin(ang)*230,ttl:5,color:"#ff6666"});
        }
      }
    }

    // Collisions
    if(e.type==="ghost"){
      if(e.visible && aabb(player.x,player.y,player.w,player.h,e.x,e.y,e.w,e.h)){ loadLevel(levelIndex); return; }
    } else if(e.type==="boss"){
      const stomping = player.vy>0 && (player.y+player.h) <= (e.y+12) && aabb(player.x,player.y,player.w,player.h,e.x,e.y,e.w,e.h);
      if(stomping){
        player.vy = -540; e.hp--;
        if(e.hp<=0){ coinTotal += L.bossReward; loadLevel(levelIndex+1); return; }
      } else if(aabb(player.x,player.y,player.w,player.h,e.x,e.y,e.w,e.h)){
        loadLevel(levelIndex); return;
      }
    } else {
      if(aabb(player.x,player.y,player.w,player.h,e.x,e.y,e.w,e.h)){ loadLevel(levelIndex); return; }
    }
  }

  // Bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx * dt; b.y += b.vy * dt; b.ttl -= dt;
    if(aabb(player.x,player.y,player.w,player.h,b.x,b.y,b.w,b.h)){ loadLevel(levelIndex); return; }
    if(b.ttl<=0) bullets.splice(i,1);
  }

  // Goal
  if(!L.boss && L.goal){
    if(aabb(player.x,player.y,player.w,player.h,L.goal.x,L.goal.y,L.goal.w,L.goal.h)){
      loadLevel(levelIndex+1); return;
    }
  }
}

// Draw
function draw(){
  const L = levels[levelIndex];
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Background and ground line
  ctx.fillStyle = L.bg; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#555"; ctx.fillRect(0,GROUND_Y,canvas.width,4);

  // Hazards
  ctx.fillStyle = "#d84315";
  for(const h of L.hazards){ ctx.fillRect(h.x,h.y,h.w,h.h); }

  // Breakables
  for(const br of L.breakables){
    ctx.fillStyle = br.broken ? "rgba(120,90,60,0.25)" : "#8d6e63";
    ctx.fillRect(br.x,br.y,br.w,br.h);
  }

  // Platforms
  ctx.fillStyle = "#90a4ae";
  for(const p of L.platforms){ ctx.fillRect(p.x,p.y,p.w,p.h); }

  // Bounce pads
  ctx.fillStyle = "#7cb342";
  for(const b of L.bouncePads){ ctx.fillRect(b.x,b.y,b.w,b.h); }

  // Conveyor zones
  ctx.fillStyle = "rgba(200,200,255,0.22)";
  for(const z of L.conveyorZones){ ctx.fillRect(z.x,z.y,z.w,z.h); }

  // Door/key
  if(L.door){ ctx.fillStyle = hasKey ? "#4caf50" : "#6d4c41"; ctx.fillRect(L.door.x,L.door.y,L.door.w,L.door.h); }
  if(L.key && !L.key.collected){ ctx.fillStyle = "#cddc39"; ctx.fillRect(L.key.x,L.key.y,L.key.w,L.key.h); }

  // Goal
  if(!L.boss && L.goal){ ctx.fillStyle = "#1e88e5"; ctx.fillRect(L.goal.x,L.goal.y,L.goal.w,L.goal.h); }

  // Coins
  for(const c of L.coins){
    if(!c.collected){ ctx.fillStyle = "#ffd700"; ctx.beginPath(); ctx.arc(c.x,c.y,c.r,0,Math.PI*2); ctx.fill(); }
  }

  // Enemies
  for(const e of L.enemies){
    let color = "#ff4444";
    if(e.type==="fly") color="#ff8a65";
    if(e.type==="chase") color="#f44336";
    if(e.type==="ghost") color = (e.visible?"#9c27b0":"rgba(156,39,176,0.3)");
    if(e.type==="turret") color="#b0bec5";
    if(e.type==="boss") color="#e53935";
    ctx.fillStyle = color;
    ctx.fillRect(e.x,e.y,e.w,e.h);
    if(e.type==="boss"){
      ctx.fillStyle="#222"; ctx.fillRect(e.x,e.y-10,e.w,6);
      const maxHp = 12; // draw bar proportionally even if world sets lower/equal hp
      ctx.fillStyle="#76ff03"; ctx.fillRect(e.x,e.y-10,(Math.max(0,e.hp)/maxHp)*e.w,6);
    }
  }

  // Bullets
  for(const b of bullets){ ctx.fillStyle = b.color || "#fff"; ctx.fillRect(b.x,b.y,b.w,b.h); }

  // Player
  ctx.fillStyle = player.color; ctx.fillRect(player.x,player.y,player.w,player.h);

  // Cave flashlight: darkness overlay with directional cone
  if(L.dark && L.flashlight){
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,0.90)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const cx = player.x + player.w/2;
    const cy = player.y + player.h/2;

    // Directional cone based on player.face
    const angle = player.face===1 ? 0 : Math.PI; // right or left
    const spread = Math.PI/4; // cone width
    const radius = 220; // flashlight range

    // Create a cone path
    ctx.globalCompositeOperation="destination-out";
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, radius, angle - spread, angle + spread);
    ctx.closePath();
    ctx.fill();

    // Soft circular glow around player for close visibility
    const glowR = 100;
    const grad = ctx.createRadialGradient(cx,cy,0,cx,cy,glowR);
    grad.addColorStop(0,"rgba(0,0,0,0)");
    grad.addColorStop(1,"rgba(0,0,0,0.90)");
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(cx,cy,glowR,0,Math.PI*2); ctx.fill();

    ctx.restore();
  } else if(L.dark){
    // Fallback circular light if flashlight disabled
    ctx.save();
    ctx.fillStyle="rgba(0,0,0,0.85)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const cx=player.x+player.w/2, cy=player.y+player.h/2, radius=130;
    const grad=ctx.createRadialGradient(cx,cy,0,cx,cy,radius);
    grad.addColorStop(0,"rgba(0,0,0,0)"); grad.addColorStop(1,"rgba(0,0,0,0.85)");
    ctx.globalCompositeOperation="destination-out";
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(cx,cy,radius,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

// Loop
let last = performance.now();
function loop(now){
  const dt = Math.min(0.033, (now-last)/1000); last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Color swap
window.addEventListener('keydown',e=>{
  if(e.code==="Digit1") player.color="#ffd166";
  if(e.code==="Digit2") player.color="#ff595e";
  if(e.code==="Digit3") player.color="#8ac926";
  if(e.code==="Digit4") player.color="#1982c4";
});
</script>
</body>
</html>
